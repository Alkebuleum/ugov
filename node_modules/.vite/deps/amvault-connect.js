import {
  verifyMessage
} from "./chunk-O7LUCWK7.js";
import {
  require_jsx_runtime
} from "./chunk-KBTYAULA.js";
import {
  require_react
} from "./chunk-QCHXOAYK.js";
import {
  __toESM
} from "./chunk-WOOG5QLI.js";

// node_modules/amvault-connect/dist/provider/AuthProvider.js
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var import_react = __toESM(require_react(), 1);

// node_modules/amvault-connect/dist/popup/amvaultPopup.js
var sharedPopup = null;
var overlayEl = null;
var isClosing = false;
function ensureOverlay() {
  if (overlayEl)
    return;
  overlayEl = document.createElement("div");
  overlayEl.id = "amvault-overlay";
  Object.assign(overlayEl.style, {
    position: "fixed",
    inset: "0",
    background: "rgba(0,0,0,0.35)",
    zIndex: "9999",
    pointerEvents: "none"
  });
  document.body.appendChild(overlayEl);
}
function preOpenAmvaultPopup(name = "amvault", w = 420, h = 640) {
  var _a, _b, _c, _d, _e, _f, _g;
  const oh = (_c = (_b = (_a = window.top) === null || _a === void 0 ? void 0 : _a.outerHeight) !== null && _b !== void 0 ? _b : window.outerHeight) !== null && _c !== void 0 ? _c : 0;
  const ow = (_f = (_e = (_d = window.top) === null || _d === void 0 ? void 0 : _d.outerWidth) !== null && _e !== void 0 ? _e : window.outerWidth) !== null && _f !== void 0 ? _f : 0;
  const y = Math.max((oh - h) / 2, 0);
  const x = Math.max((ow - w) / 2, 0);
  if (sharedPopup && !sharedPopup.closed)
    return sharedPopup;
  sharedPopup = (_g = window.open("about:blank", name, `toolbar=0,location=0,status=0,menubar=0,scrollbars=1,resizable=1,width=${w},height=${h},top=${y},left=${x}`)) !== null && _g !== void 0 ? _g : null;
  ensureOverlay();
  window.addEventListener("beforeunload", () => {
    try {
      sharedPopup === null || sharedPopup === void 0 ? void 0 : sharedPopup.close();
    } catch {
    }
    sharedPopup = null;
    if ((overlayEl === null || overlayEl === void 0 ? void 0 : overlayEl.parentNode) && overlayEl.parentNode.contains(overlayEl)) {
      try {
        overlayEl.parentNode.removeChild(overlayEl);
      } catch {
      }
    }
    overlayEl = null;
    isClosing = false;
  }, { once: true });
  return sharedPopup;
}
function getSharedPopup() {
  return sharedPopup && !sharedPopup.closed ? sharedPopup : null;
}
async function closeSharedPopup() {
  if (isClosing)
    return;
  isClosing = true;
  try {
    if (sharedPopup && !sharedPopup.closed)
      sharedPopup.close();
  } catch {
  }
  sharedPopup = null;
  if (overlayEl) {
    const parent = overlayEl.parentNode;
    if (parent && parent.contains(overlayEl)) {
      try {
        parent.removeChild(overlayEl);
      } catch {
      }
    }
  }
  overlayEl = null;
  await Promise.resolve();
  isClosing = false;
}
async function closePopupThen(cb) {
  await closeSharedPopup();
  setTimeout(cb, 0);
}

// node_modules/amvault-connect/dist/popup/amvaultProvider.js
var STORAGE_FALLBACK_KEYS = ["amid:lastResult", "amvault:payload"];
function base64url(json) {
  const s = btoa(unescape(encodeURIComponent(JSON.stringify(json)))).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
  return s;
}
function makeNonce() {
  const b = new Uint8Array(16);
  crypto.getRandomValues(b);
  return Array.from(b).map((x) => x.toString(16).padStart(2, "0")).join("");
}
function requestPopup({ method, app, chainId, origin, amvaultUrl, payload, nonce = makeNonce(), timeoutMs = 5e4, debug = false }) {
  return new Promise((resolve, reject) => {
    try {
      const url = new URL(amvaultUrl);
      url.searchParams.set("method", method);
      url.searchParams.set("app", app);
      url.searchParams.set("chainId", String(chainId));
      url.searchParams.set("origin", origin);
      url.searchParams.set("nonce", nonce);
      url.searchParams.set("redirect", "postmessage");
      if (payload)
        url.searchParams.set("payload", base64url(payload));
      const popup = preOpenAmvaultPopup();
      if (!popup)
        return reject(new Error("Popup blocked"));
      try {
        popup.location.href = url.toString();
      } catch {
        popup.location.assign(url.toString());
      }
      let settled = false;
      let timer;
      const amvaultOrigin = url.origin;
      const cleanup = () => {
        if (timer)
          window.clearTimeout(timer);
        window.removeEventListener("message", onMsg);
        window.removeEventListener("storage", onStorage);
        try {
          closeSharedPopup();
        } catch {
        }
      };
      const finishOk = (data) => {
        if (settled)
          return;
        settled = true;
        cleanup();
        resolve(data);
      };
      const finishErr = (err) => {
        if (settled)
          return;
        settled = true;
        cleanup();
        reject(err instanceof Error ? err : new Error(String(err)));
      };
      const onMsg = (ev) => {
        if (amvaultOrigin && ev.origin !== amvaultOrigin)
          return;
        if (ev.source !== popup)
          return;
        const data = ev.data;
        if (!data)
          return;
        if (debug)
          console.log("[amvault][pm]", data);
        if (method === "signin" && data.type === "amvault:auth")
          return finishOk(data);
        if (method === "eth_sendTransaction" && data.type === "amvault:tx")
          return finishOk(data);
        if (data.type === "amvault:error")
          return finishErr(new Error(data.error || "Request rejected"));
      };
      window.addEventListener("message", onMsg);
      const onStorage = (ev) => {
        if (!ev.key || !STORAGE_FALLBACK_KEYS.includes(ev.key))
          return;
        if (!ev.newValue)
          return;
        try {
          const data = JSON.parse(ev.newValue);
          if (debug)
            console.log("[amvault][storage]", data);
          if (method === "signin" && (data === null || data === void 0 ? void 0 : data.type) === "amvault:auth")
            return finishOk(data);
          if (method === "eth_sendTransaction" && (data === null || data === void 0 ? void 0 : data.type) === "amvault:tx")
            return finishOk(data);
          if ((data === null || data === void 0 ? void 0 : data.type) === "amvault:error")
            return finishErr(new Error(data.error || "Request rejected"));
        } catch {
        }
      };
      window.addEventListener("storage", onStorage);
      timer = window.setTimeout(() => finishErr(new Error("Timed out waiting for AmVault")), timeoutMs);
    } catch (e) {
      reject(e);
    }
  });
}
async function openSignin(args) {
  const payload = args.message ? { message: args.message } : void 0;
  return requestPopup({
    method: "signin",
    app: args.app,
    chainId: args.chainId,
    origin: args.origin,
    amvaultUrl: args.amvaultUrl,
    nonce: args.nonce,
    debug: !!args.debug,
    payload
  });
}
async function sendTransaction(req, opts) {
  var _a;
  const origin = window.location.origin;
  const payload = {
    to: req.to,
    value: req.value,
    data: req.data,
    gas: req.gas,
    maxFeePerGasGwei: req.maxFeePerGasGwei,
    maxPriorityFeePerGasGwei: req.maxPriorityFeePerGasGwei
  };
  const resp = await requestPopup({
    method: "eth_sendTransaction",
    app: opts.app,
    chainId: req.chainId,
    origin,
    amvaultUrl: opts.amvaultUrl,
    payload,
    timeoutMs: (_a = opts.timeoutMs) !== null && _a !== void 0 ? _a : 5e4,
    debug: !!opts.debug
  });
  if (!resp.ok)
    throw new Error(resp.error || "Transaction rejected");
  if (!resp.txHash)
    throw new Error("No txHash returned from AmVault");
  return resp.txHash;
}

// node_modules/amvault-connect/dist/provider/AuthProvider.js
var DEFAULT_TTL = 24 * 60 * 60 * 1e3;
var makeStorageKeys = (prefix) => ({
  session: `${prefix}.session`,
  nonce: `${prefix}.nonce`
});
var AuthContext = (0, import_react.createContext)({
  session: null,
  signin: async () => {
  },
  signout: () => {
  },
  status: "idle",
  error: null
});
function AuthProvider({ children, config }) {
  var _a;
  const ttl = (_a = config.sessionTtlMs) !== null && _a !== void 0 ? _a : DEFAULT_TTL;
  const keys = (0, import_react.useMemo)(() => makeStorageKeys(config.storagePrefix || "amvault"), [config.storagePrefix]);
  const [session, setSession] = (0, import_react.useState)(null);
  const [status, setStatus] = (0, import_react.useState)("idle");
  const [error, setError] = (0, import_react.useState)(null);
  (0, import_react.useEffect)(() => {
    setStatus("checking");
    try {
      const raw = localStorage.getItem(keys.session);
      if (raw) {
        const s = JSON.parse(raw);
        if (Date.now() < s.expiresAt) {
          setSession(s);
          setStatus("ready");
          return;
        }
      }
      setStatus("ready");
    } catch (e) {
      setStatus("failed");
      setError("Failed to load session");
    }
  }, [keys.session]);
  const signout = () => {
    localStorage.removeItem(keys.session);
    setSession(null);
  };
  const makeNonce2 = () => {
    const b = new Uint8Array(16);
    crypto.getRandomValues(b);
    return Array.from(b).map((x) => x.toString(16).padStart(2, "0")).join("");
  };
  const buildMessage = (nonce) => {
    const origin = window.location.origin;
    if (typeof config.messageBuilder === "function") {
      return config.messageBuilder({
        appName: config.appName,
        origin,
        chainId: config.chainId,
        nonce
      });
    }
    const domain = window.location.host;
    return [
      `${domain} wants you to sign in with your account:`,
      ``,
      `App: ${config.appName}`,
      `Nonce: ${nonce}`,
      `URI: ${origin}`,
      `Chain ID: ${config.chainId}`,
      `Version: 1`
    ].join("\\n");
  };
  const signin = async () => {
    var _a2, _b, _c;
    try {
      setError(null);
      setStatus("checking");
      const nonce = makeNonce2();
      localStorage.setItem(keys.nonce, nonce);
      const msg = buildMessage(nonce);
      const resp = await openSignin({
        app: config.appName,
        chainId: config.chainId,
        origin: window.location.origin,
        nonce,
        amvaultUrl: config.amvaultUrl,
        debug: !!config.debug,
        message: msg
      });
      if (!(resp === null || resp === void 0 ? void 0 : resp.ok))
        throw new Error((resp === null || resp === void 0 ? void 0 : resp.error) || "Sign-in rejected");
      const { address, signature, chainId, nonce: got } = resp;
      if (!address || !signature || !chainId || !got)
        throw new Error("Malformed response");
      if (got !== nonce)
        throw new Error("Nonce mismatch");
      if (Number(chainId) !== config.chainId)
        throw new Error(`Wrong network: got ${chainId}, expected ${config.chainId}`);
      const origin = window.location.origin;
      const toVerify = typeof resp.message === "string" && resp.message.trim() ? resp.message : msg;
      const recovered = verifyMessage(toVerify, signature).toLowerCase();
      if (recovered !== String(address).toLowerCase())
        throw new Error("Signature invalid (recovered != address)");
      if (toVerify !== msg) {
        if (!toVerify.includes(`Nonce: ${nonce}`))
          throw new Error("Signed message missing expected nonce");
        if (!toVerify.includes(`URI: ${origin}`))
          throw new Error("Signed message missing expected origin");
        if (!toVerify.includes(`Chain ID: ${config.chainId}`))
          throw new Error("Signed message missing expected chain id");
        const enforce = (_a2 = config.enforceAppName) !== null && _a2 !== void 0 ? _a2 : true;
        if (enforce && !toVerify.includes(`App: ${config.appName}`)) {
          throw new Error("Signed message app does not match configuration");
        }
      }
      if ((_b = config.registry) === null || _b === void 0 ? void 0 : _b.isRegistered) {
        const ok = await config.registry.isRegistered(address);
        if (!ok)
          throw new Error("Address not registered");
      }
      let ain = "";
      if (typeof resp.ain === "string" && resp.ain.trim())
        ain = resp.ain.trim();
      else if (typeof resp.amid === "string" && resp.amid.trim())
        ain = resp.amid.trim();
      if (!ain && ((_c = config.registry) === null || _c === void 0 ? void 0 : _c.getAin)) {
        try {
          const gotAin = await config.registry.getAin(address);
          if (gotAin)
            ain = gotAin;
        } catch {
        }
      }
      if (!ain)
        ain = `ain-${address.slice(2, 8)}`;
      const now = Date.now();
      const sess = { ain, address, issuedAt: now, expiresAt: now + ttl };
      localStorage.setItem(keys.session, JSON.stringify(sess));
      setSession(sess);
      setStatus("ready");
    } catch (e) {
      setError((e === null || e === void 0 ? void 0 : e.message) || "Sign-in failed");
      setStatus("ready");
    } finally {
      localStorage.removeItem(keys.nonce);
    }
  };
  const value = (0, import_react.useMemo)(() => ({
    session,
    signin,
    signout,
    status,
    error
  }), [session, status, error]);
  return (0, import_jsx_runtime.jsx)(AuthContext.Provider, { value, children });
}

// node_modules/amvault-connect/dist/provider/useAuth.js
var import_react2 = __toESM(require_react(), 1);
function useAuth() {
  return (0, import_react2.useContext)(AuthContext);
}

// node_modules/amvault-connect/dist/evm.js
var EVM = {
  CHAIN_ID: 0
};
function setChainId(chainId) {
  EVM.CHAIN_ID = chainId;
}
export {
  AuthContext,
  AuthProvider,
  EVM,
  closePopupThen,
  closeSharedPopup,
  getSharedPopup,
  makeStorageKeys,
  openSignin,
  preOpenAmvaultPopup,
  sendTransaction,
  setChainId,
  useAuth
};
//# sourceMappingURL=amvault-connect.js.map
